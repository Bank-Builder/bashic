#!/bin/bash

# BASHIC - BASIC Interpreter in Bash
# Version 1.0
# A complete BASIC interpreter written entirely in bash

set -euo pipefail

# ===== UTILITY MODULE =====
#!/bin/bash
# BASHIC Utility Functions Module
# bashic.util.sh - Core utilities, constants, and global variables

# Constants
readonly MAX_ARRAY_SIZE=10000
readonly BASIC_INDEX_BASE=1  # BASIC uses 1-based indexing
readonly MAX_LINE_NUMBER=99999

# Global variables
declare -A PROGRAM_LINES      # Program lines indexed by line number
declare -A NUMERIC_VARS       # Numeric variables
declare -A STRING_VARS        # String variables  
declare -A ARRAYS            # Arrays
declare -a GOSUB_STACK       # GOSUB return stack
declare -a FOR_STACK         # FOR loop stack
declare -a WHILE_STACK       # WHILE loop stack

CURRENT_LINE=0
PROGRAM_COUNTER=0
RUNNING=false
DEBUG=false
INKEY_BUFFER=""  # Buffer for INKEY$ to read characters one at a time
OLD_TTY_SETTINGS=""  # Store original terminal settings
declare -a DATA_ITEMS  # DATA statement items
DATA_POINTER=0  # Current position in DATA_ITEMS

# Error handling with context
error_with_context() {
    local message="$1"
    local context=""
    
    if [[ $CURRENT_LINE -gt 0 ]]; then
        context=" (line $CURRENT_LINE"
        if [[ -n "${PROGRAM_LINES[$CURRENT_LINE]:-}" ]]; then
            context="$context: ${PROGRAM_LINES[$CURRENT_LINE]}"
        fi
        context="$context)"
    fi
    
    echo "ERROR: $message$context" >&2
    exit 1
}

# Legacy error function for backward compatibility
error() {
    error_with_context "$1"
}

# Usage information
usage() {
    echo "Usage: $0 [options] <program.bas>"
    echo "Options:"
    echo "  -d, --debug    Enable debug output"
    echo "  -h, --help     Show this help message"
    echo "  -v, --version  Show version information"
    exit 0
}

# Debug output
debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo "DEBUG: $1" >&2
    fi
}

# Trim whitespace from string
trim() {
    local str="$1"
    str="${str#"${str%%[![:space:]]*}"}"  # Remove leading whitespace
    str="${str%"${str##*[![:space:]]}"}"  # Remove trailing whitespace
    echo "$str"
}

# Check if string is numeric
is_numeric() {
    local str="$1"
    [[ "$str" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]
}

# Generic stack push function
stack_push() {
    local stack_name="$1"
    local value="$2"
    
    case "$stack_name" in
        "GOSUB_STACK")
            GOSUB_STACK+=("$value")
            ;;
        "FOR_STACK")
            FOR_STACK+=("$value")
            ;;
        "WHILE_STACK")
            WHILE_STACK+=("$value")
            ;;
        *)
            error "Unknown stack: $stack_name"
            ;;
    esac
}

# Generic stack pop function
stack_pop() {
    local stack_name="$1"
    local result=""
    
    case "$stack_name" in
        "GOSUB_STACK")
            if [[ ${#GOSUB_STACK[@]} -gt 0 ]]; then
                result="${GOSUB_STACK[-1]}"
                unset GOSUB_STACK[-1]
            fi
            ;;
        "FOR_STACK")
            if [[ ${#FOR_STACK[@]} -gt 0 ]]; then
                result="${FOR_STACK[-1]}"
                unset FOR_STACK[-1]
            fi
            ;;
        "WHILE_STACK")
            if [[ ${#WHILE_STACK[@]} -gt 0 ]]; then
                result="${WHILE_STACK[-1]}"
                unset WHILE_STACK[-1]
            fi
            ;;
        *)
            error "Unknown stack: $stack_name"
            ;;
    esac
    
    echo "$result"
}

# ===== MATH MODULE =====
#!/bin/bash
# BASHIC Math Functions Module
# bashic.math.sh - Mathematical functions (ABS, INT, SGN, SQR)

# Mathematical functions
math_abs() {
    local n="$1"
    if [[ $(echo "$n < 0" | bc -l 2>/dev/null || echo "0") == "1" ]]; then
        echo "$n * -1" | bc -l 2>/dev/null || echo "${n#-}"
    else
        echo "$n"
    fi
}

math_int() {
    local n="$1"
    echo "$n" | cut -d. -f1
}

math_sgn() {
    local n="$1"
    if [[ "$n" =~ ^-.*$ ]]; then
        echo "-1"
    elif [[ "$n" == "0" || "$n" == "0.0" ]]; then
        echo "0"
    else
        echo "1"
    fi
}

math_sqr() {
    local n="$1"
    # Simple square root using bash arithmetic (limited precision)
    if command -v bc >/dev/null 2>&1; then
        echo "sqrt($n)" | bc -l
    else
        # Fallback: Newton's method approximation
        local x="$n"
        local prev=0
        while [[ "$x" != "$prev" ]]; do
            prev="$x"
            x=$(( (x + n/x) / 2 ))
        done
        echo "$x"
    fi
}

math_rnd() {
    local n="$1"
    # Random number between 0 and 1
    # Use RANDOM (0-32767) and scale to 0-1
    local result=$(echo "scale=6; $RANDOM / 32767" | bc -l 2>/dev/null || echo "0.$RANDOM")
    # Ensure leading zero for values < 1
    if [[ "$result" =~ ^\. ]]; then
        result="0${result}"
    fi
    echo "$result"
}

# ===== KEYBOARD MODULE =====
#!/bin/bash
# BASHIC Keyboard Module
# bashic.kbd.sh - Keyboard input handling

# Global variables for keyboard input
BASHIC_INKEY_BUFFER=""  # Buffer for non-interactive input
BASHIC_TTY_SETTINGS=""  # Store original terminal settings

# Initialize keyboard handling
init_keyboard() {
    # Save current terminal settings and check if we're in a terminal
    if [ -t 0 ]; then
        BASHIC_TTY_SETTINGS=$(stty -g 2>/dev/null)
        # Set terminal to raw mode with proper settings
        stty raw -echo min 0 time 0 2>/dev/null || true
    else
        BASHIC_TTY_SETTINGS=""
    fi
}

# Function to convert key to readable name
key_name() {
    local key="$1"
    case "$key" in
        $'\r') echo "ENTER" ;;
        $'\e') echo "ESC" ;;
        $'\t') echo "TAB" ;;
        $'\b'|$'\x7f') echo "BACKSPACE" ;;  # handle DEL too
        $' ') echo " " ;;
        *) echo "$key" ;;
    esac
}

# Function to handle cleanup
cleanup_keyboard() {
    # Restore terminal settings if we're in a terminal
    if [ -n "$BASHIC_TTY_SETTINGS" ]; then
        stty "$BASHIC_TTY_SETTINGS" 2>/dev/null || true
    fi
}

# Get a single character from keyboard or buffer
get_key() {
    local char
    if [ -t 0 ]; then
        # Use read with timeout
        IFS= read -r -n1 -t 1 char 2>/dev/null || char=""
    else
        IFS= read -r -n1 -t 4 char || char=""
    fi

    printf '%s' "$char"
}



# INKEY$ function for BASIC compatibility
INKEY_STR() {
    local key=$(get_key)
    if [ -n "$key" ]; then
        key_name "$key"
    else
        echo ""
    fi
}

# Set up cleanup trap
trap cleanup_keyboard EXIT
# ===== STRING MODULE =====
#!/bin/bash
# BASHIC String Functions Module
# bashic.string.sh - String functions (LEN, LEFT$, RIGHT$, MID$, ASC, CHR$, VAL, STR$)

# String functions
str_len() {
    echo "${#1}"
}

str_left() {
    local str="$1"
    local len="$2"
    echo "${str:0:$len}"
}

str_right() {
    local str="$1"
    local len="$2"
    local str_len="${#str}"
    local start=$((str_len - len))
    [[ $start -lt 0 ]] && start=0
    echo "${str:$start}"
}

str_mid() {
    local str="$1"
    local start="$2"
    local len="${3:-${#str}}"
    start=$((start - BASIC_INDEX_BASE))  # BASIC uses 1-based indexing
    [[ $start -lt 0 ]] && start=0
    echo "${str:$start:$len}"
}

str_asc() {
    local str="$1"
    [[ -z "$str" ]] && echo "0" && return
    printf "%d" "'${str:0:1}"
}

str_chr() {
    local code="$1"
    printf "\\$(printf "%03o" "$code")"
}

str_val() {
    local str="$1"
    # Extract numeric part from beginning of string
    if [[ "$str" =~ ^[[:space:]]*(-?[0-9]+(\.[0-9]+)?) ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo "0"
    fi
}

str_space() {
    local n="$1"
    printf '%*s' "$n" ''
}

str_time() {
    date +%H:%M:%S
}

str_tab() {
    local col="$1"
    # Return spaces to reach column position
    # For simplicity, just return N spaces
    printf '%*s' "$col" ''
}

# ===== SCREEN MODULE =====
#!/bin/bash
# BASHIC Screen Functions Module
# bashic.screen.sh - Screen control using ANSI escape codes

# Global screen state
CURRENT_FG_COLOR=37  # White foreground
CURRENT_BG_COLOR=40  # Black background
SCREEN_WIDTH=80

# Clear screen
screen_cls() {
    echo -ne "\033[2J\033[H"
}

# Position cursor at row, column
screen_locate() {
    local row="${1:-1}"
    local col="${2:-1}"
    local cursor_visible="${3:-1}"  # Optional cursor visibility (ignored)
    
    # ANSI escape: ESC[row;colH
    echo -ne "\033[${row};${col}H"
}

# Set text and background color
screen_color() {
    local fg="${1:-7}"  # Default white
    local bg="${2:-0}"  # Default black
    
    # Convert BASIC color codes (0-15) to ANSI (30-37, 90-97 for fg; 40-47, 100-107 for bg)
    # BASIC: 0=black, 1=blue, 2=green, 3=cyan, 4=red, 5=magenta, 6=brown/yellow, 7=white
    # BASIC: 8-15 are bright versions
    
    local ansi_fg=37
    local ansi_bg=40
    
    # Map foreground color
    case "$fg" in
        0) ansi_fg=30 ;;  # Black
        1) ansi_fg=34 ;;  # Blue
        2) ansi_fg=32 ;;  # Green
        3) ansi_fg=36 ;;  # Cyan
        4) ansi_fg=31 ;;  # Red
        5) ansi_fg=35 ;;  # Magenta
        6) ansi_fg=33 ;;  # Yellow
        7) ansi_fg=37 ;;  # White
        8) ansi_fg=90 ;;  # Bright Black (Gray)
        9) ansi_fg=94 ;;  # Bright Blue
        10) ansi_fg=92 ;; # Bright Green
        11) ansi_fg=96 ;; # Bright Cyan
        12) ansi_fg=91 ;; # Bright Red
        13) ansi_fg=95 ;; # Bright Magenta
        14) ansi_fg=93 ;; # Bright Yellow
        15) ansi_fg=97 ;; # Bright White
    esac
    
    # Map background color
    case "$bg" in
        0) ansi_bg=40 ;;  # Black
        1) ansi_bg=44 ;;  # Blue
        2) ansi_bg=42 ;;  # Green
        3) ansi_bg=46 ;;  # Cyan
        4) ansi_bg=41 ;;  # Red
        5) ansi_bg=45 ;;  # Magenta
        6) ansi_bg=43 ;;  # Yellow
        7) ansi_bg=47 ;;  # White
    esac
    
    CURRENT_FG_COLOR=$ansi_fg
    CURRENT_BG_COLOR=$ansi_bg
    
    echo -ne "\033[${ansi_fg};${ansi_bg}m"
}

# Beep
screen_beep() {
    echo -ne "\a"
}

# Sound - play tone at frequency for duration
screen_sound() {
    local frequency="$1"
    local duration_ms="$2"
    
    # Convert milliseconds to seconds for ffplay
    local duration_sec=$(echo "scale=3; $duration_ms / 1000" | bc -l 2>/dev/null || echo "0.25")
    
    # Use ffplay to generate sine wave tone
    # -nodisp: no display window
    # -autoexit: exit when done
    # -f lavfi: use lavfi (audio filter)
    # -i sine: generate sine wave at specified frequency and duration
    if command -v ffplay >/dev/null 2>&1; then
        ffplay -nodisp -autoexit -f lavfi -i "sine=f=${frequency}:d=${duration_sec}" >/dev/null 2>&1 &
    else
        # Fallback to beep if ffplay not available
        echo -ne "\a"
    fi
}

# Set screen width (just store, don't actually resize)
screen_width() {
    local width="$1"
    SCREEN_WIDTH=$width
    # Note: Can't actually resize terminal from bash
}


# ===== GRAPHICS MODULE =====
#!/bin/bash
# BASHIC Graphics Module
# bashic.graphics.sh - Graphics functions for LINE command and text-based graphics

# Graphics buffer for LINE command
declare -a BASHIC_GRAPHICS_BUFFER  # 2D array for text graphics
BASHIC_GRAPHICS_WIDTH=80
BASHIC_GRAPHICS_HEIGHT=25

# Initialize graphics buffer
init_graphics_buffer() {
    # Clear the graphics buffer
    BASHIC_GRAPHICS_BUFFER=()
    
    # Initialize with spaces
    local row=0
    while [[ $row -lt $BASHIC_GRAPHICS_HEIGHT ]]; do
        local col=0
        local line=""
        while [[ $col -lt $BASHIC_GRAPHICS_WIDTH ]]; do
            line="${line} "
            col=$((col + 1))
        done
        BASHIC_GRAPHICS_BUFFER[$row]="$line"
        row=$((row + 1))
    done
    
    debug "Graphics buffer initialized: ${BASHIC_GRAPHICS_WIDTH}x${BASHIC_GRAPHICS_HEIGHT}"
}

# Set a pixel in the graphics buffer
set_pixel() {
    local x="$1"
    local y="$2"
    local char="${3:-*}"
    
    # Convert graphics coordinates to buffer coordinates
    # Graphics coordinates are typically 0-based, buffer is 0-based
    local buffer_x=$x
    local buffer_y=$y
    
    # Check bounds
    if [[ $buffer_x -ge 0 && $buffer_x -lt $BASHIC_GRAPHICS_WIDTH && 
          $buffer_y -ge 0 && $buffer_y -lt $BASHIC_GRAPHICS_HEIGHT ]]; then
        local line="${BASHIC_GRAPHICS_BUFFER[$buffer_y]}"
        local new_line="${line:0:$buffer_x}${char}${line:$((buffer_x + 1))}"
        BASHIC_GRAPHICS_BUFFER[$buffer_y]="$new_line"
    fi
}

# Draw a line between two points using Bresenham's algorithm
draw_line() {
    local x1="$1"
    local y1="$2"
    local x2="$3"
    local y2="$4"
    local char="${5:-*}"
    
    debug "Drawing line from ($x1,$y1) to ($x2,$y2) with char '$char'"
    
    # Bresenham's line algorithm
    local dx=$((x2 - x1))
    local dy=$((y2 - y1))
    
    # Determine step direction
    local step_x=1
    local step_y=1
    if [[ $dx -lt 0 ]]; then
        dx=$((-dx))
        step_x=-1
    fi
    if [[ $dy -lt 0 ]]; then
        dy=$((-dy))
        step_y=-1
    fi
    
    # Determine which axis has the greater change
    local x=$x1
    local y=$y1
    
    if [[ $dx -gt $dy ]]; then
        # X-axis dominant
        local error=$((dx / 2))
        while [[ $x -ne $x2 ]]; do
            set_pixel "$x" "$y" "$char"
            error=$((error - dy))
            if [[ $error -lt 0 ]]; then
                y=$((y + step_y))
                error=$((error + dx))
            fi
            x=$((x + step_x))
        done
    else
        # Y-axis dominant
        local error=$((dy / 2))
        while [[ $y -ne $y2 ]]; do
            set_pixel "$x" "$y" "$char"
            error=$((error - dx))
            if [[ $error -lt 0 ]]; then
                x=$((x + step_x))
                error=$((error + dy))
            fi
            y=$((y + step_y))
        done
    fi
    
    # Draw the final point
    set_pixel "$x2" "$y2" "$char"
}

# Display the graphics buffer
display_graphics() {
    echo -ne "\033[H"  # Move cursor to home position
    local row=0
    while [[ $row -lt $BASHIC_GRAPHICS_HEIGHT ]]; do
        echo "${BASHIC_GRAPHICS_BUFFER[$row]}"
        row=$((row + 1))
    done
}

# Clear the graphics buffer
clear_graphics() {
    init_graphics_buffer
}

# Execute SCREEN command
execute_screen() {
    local mode="${1:-0}"
    mode=$(trim "$mode")
    
    # Evaluate mode if it's an expression
    local screen_mode=$(evaluate_expression "$mode")
    
    debug "SCREEN: Setting display mode to $screen_mode"
    
    case "$screen_mode" in
        0)
            # Text mode (80x25) - default terminal mode
            SCREEN_WIDTH=80
            debug "SCREEN 0: Text mode (80x25)"
            ;;
        1)
            # Medium resolution graphics (320x200) - simulate with wider terminal
            SCREEN_WIDTH=80  # Keep reasonable width for terminal
            debug "SCREEN 1: Medium resolution graphics mode (simulated)"
            ;;
        2)
            # High resolution graphics (640x200) - simulate with wider terminal
            SCREEN_WIDTH=80  # Keep reasonable width for terminal
            debug "SCREEN 2: High resolution graphics mode (simulated)"
            ;;
        3)
            # Extended text mode (80x25) - same as mode 0
            SCREEN_WIDTH=80
            debug "SCREEN 3: Extended text mode (80x25)"
            ;;
        4)
            # Very high resolution (640x400) - simulate with wider terminal
            SCREEN_WIDTH=80  # Keep reasonable width for terminal
            debug "SCREEN 4: Very high resolution graphics mode (simulated)"
            ;;
        *)
            debug "SCREEN $screen_mode: Unknown mode, defaulting to text mode"
            SCREEN_WIDTH=80
            ;;
    esac
    
    # Clear screen when changing modes (like GW-BASIC)
    screen_cls
}

# Execute LINE command
execute_line() {
    local stmt="${1:-}"
    stmt=$(trim "$stmt")
    
    debug "LINE command: $stmt"
    
    # Parse LINE command syntax:
    # LINE (x1,y1)-(x2,y2) [,color] [,B[F]]
    # LINE (x1,y1)-(x2,y2) [,color] [,BF]
    
    # Parse LINE command using a simpler approach
    if [[ "$stmt" =~ ^\(.*\)-\(.*\) ]]; then
        # Extract coordinates using parameter expansion
        local coords="${stmt#*(}"
        local point1="${coords%%)-*}"
        coords="${coords#*)-}"
        local point2="${coords%%)*}"
        local options="${coords#*)}"
        
        # Parse coordinates - remove parentheses and split by comma
        local coords1=$(echo "$point1" | sed 's/[()]//g')
        local coords2=$(echo "$point2" | sed 's/[()]//g')
        
        if [[ "$coords1" =~ ^([^,]+),([^,]+)$ ]]; then
            local x1=$(evaluate_expression "${BASH_REMATCH[1]}")
            local y1=$(evaluate_expression "${BASH_REMATCH[2]}")
        else
            error "Invalid LINE coordinates: $coords1"
            return
        fi
        
        if [[ "$coords2" =~ ^([^,]+),([^,]+)$ ]]; then
            local x2=$(evaluate_expression "${BASH_REMATCH[1]}")
            local y2=$(evaluate_expression "${BASH_REMATCH[2]}")
        else
            error "Invalid LINE coordinates: $coords2"
            return
        fi
        
        # Parse options
        local color="*"
        local box_mode=""
        
        if [[ -n "$options" ]]; then
            options=$(trim "$options")
            # Remove leading comma
            options="${options#,}"
            
            # Check for box mode (B or BF)
            if [[ "$options" =~ ,[[:space:]]*B[[:space:]]*F?[[:space:]]*$ ]]; then
                box_mode="${BASH_REMATCH[0]}"
                options="${options%%,*}"
            elif [[ "$options" =~ ,[[:space:]]*B[[:space:]]*$ ]]; then
                box_mode="${BASH_REMATCH[0]}"
                options="${options%%,*}"
            fi
            
            # Parse color if present
            if [[ -n "$options" ]]; then
                options=$(trim "$options")
                options="${options#,}"
                if [[ -n "$options" ]]; then
                    color=$(evaluate_expression "$options")
                fi
            fi
        fi
        
        debug "LINE: ($x1,$y1) to ($x2,$y2), color='$color', box='$box_mode'"
        
        # Draw the line or box
        if [[ -n "$box_mode" ]]; then
            # Draw box
            draw_line "$x1" "$y1" "$x2" "$y1" "$color"  # Top
            draw_line "$x2" "$y1" "$x2" "$y2" "$color"  # Right
            draw_line "$x2" "$y2" "$x1" "$y2" "$color"  # Bottom
            draw_line "$x1" "$y2" "$x1" "$y1" "$color"  # Left
            
            # If BF (box fill), fill the box
            if [[ "$box_mode" =~ BF ]]; then
                local min_x=$x1
                local max_x=$x2
                local min_y=$y1
                local max_y=$y2
                
                if [[ $x1 -gt $x2 ]]; then
                    min_x=$x2
                    max_x=$x1
                fi
                if [[ $y1 -gt $y2 ]]; then
                    min_y=$y2
                    max_y=$y1
                fi
                
                local fill_y=$((min_y + 1))
                while [[ $fill_y -lt $max_y ]]; do
                    local fill_x=$((min_x + 1))
                    while [[ $fill_x -lt $max_x ]]; do
                        set_pixel "$fill_x" "$fill_y" "$color"
                        fill_x=$((fill_x + 1))
                    done
                    fill_y=$((fill_y + 1))
                done
            fi
        else
            # Draw simple line
            draw_line "$x1" "$y1" "$x2" "$y2" "$color"
        fi
        
        # Display the graphics buffer
        display_graphics
        
    else
        error "Invalid LINE statement: $stmt"
    fi
}

# ===== EVAL MODULE =====
#!/bin/bash
# BASHIC Expression Evaluation Module
# bashic.eval.sh - Expression evaluation, operators, and condition evaluation

# Evaluate expression (optimized with single regex pattern)
evaluate_expression() {
    local expr="$1"
    expr=$(trim "$expr")
    
    debug "Evaluating expression: $expr"
    
    # Handle string literals
    if [[ "$expr" =~ ^\"(.*)\"$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return
    fi
    
    # Handle special functions (before string variables)
    if [[ "$expr" == "INKEY$" ]]; then
        # Use the kbd module's INKEY$ function
        INKEY_STR
        return
    fi
    
    if [[ "$expr" == "TIME$" ]]; then
        # Return current time as HH:MM:SS
        str_time
        return
    fi
    
    # Handle string variables
    if [[ "$expr" =~ ^[A-Z][A-Z0-9_]*\$$ ]]; then
        local var_name="$expr"
        echo "${STRING_VARS[$var_name]:-}"
        return
    fi
    
    # Handle numeric variables (including integer variables with % suffix)
    if [[ "$expr" =~ ^[A-Z][A-Z0-9_]*%?$ ]]; then
        local var_name="$expr"
        echo "${NUMERIC_VARS[$var_name]:-0}"
        return
    fi
    
    # Handle numeric literals
    if is_numeric "$expr"; then
        echo "$expr"
        return
    fi
    
    # Handle function calls (check before array access)
    local func_regex='^([A-Z]+\$?)\(([^)]*)\)$'
    if [[ "$expr" =~ $func_regex ]]; then
        local func="${BASH_REMATCH[1]}"
        local arg="${BASH_REMATCH[2]}"
        
        # Check if it's a known function (not an array)
        case "$func" in
            "ABS")
                arg=$(evaluate_expression "$arg")
                math_abs "$arg"
                return
                ;;
            "INT")
                arg=$(evaluate_expression "$arg")
                math_int "$arg"
                return
                ;;
            "SGN")
                arg=$(evaluate_expression "$arg")
                math_sgn "$arg"
                return
                ;;
            "SQR")
                arg=$(evaluate_expression "$arg")
                math_sqr "$arg"
                return
                ;;
            "RND")
                arg=$(evaluate_expression "$arg")
                math_rnd "$arg"
                return
                ;;
            "LEN")
                arg=$(evaluate_expression "$arg")
                str_len "$arg"
                return
                ;;
            "LEFT$")
                if [[ "$arg" =~ ^([^,]+),([^,]+)$ ]]; then
                    local str_arg="${BASH_REMATCH[1]}"
                    local len_arg="${BASH_REMATCH[2]}"
                    str_arg=$(evaluate_expression "$(trim "$str_arg")")
                    len_arg=$(evaluate_expression "$(trim "$len_arg")")
                    str_left "$str_arg" "$len_arg"
                    return
                fi
                ;;
            "RIGHT$")
                if [[ "$arg" =~ ^([^,]+),([^,]+)$ ]]; then
                    local str_arg="${BASH_REMATCH[1]}"
                    local len_arg="${BASH_REMATCH[2]}"
                    str_arg=$(evaluate_expression "$(trim "$str_arg")")
                    len_arg=$(evaluate_expression "$(trim "$len_arg")")
                    str_right "$str_arg" "$len_arg"
                    return
                fi
                ;;
            "MID$")
                if [[ "$arg" =~ ^([^,]+),([^,]+),([^,]+)$ ]]; then
                    local str_arg="${BASH_REMATCH[1]}"
                    local start_arg="${BASH_REMATCH[2]}"
                    local len_arg="${BASH_REMATCH[3]}"
                    str_arg=$(evaluate_expression "$(trim "$str_arg")")
                    start_arg=$(evaluate_expression "$(trim "$start_arg")")
                    len_arg=$(evaluate_expression "$(trim "$len_arg")")
                    str_mid "$str_arg" "$start_arg" "$len_arg"
                    return
                fi
                ;;
            "ASC")
                arg=$(evaluate_expression "$arg")
                str_asc "$arg"
                return
                ;;
            "CHR$")
                arg=$(evaluate_expression "$arg")
                str_chr "$arg"
                return
                ;;
            "VAL")
                arg=$(evaluate_expression "$arg")
                str_val "$arg"
                return
                ;;
            "STR$")
                arg=$(evaluate_expression "$arg")
                echo "$arg"
                return
                ;;
            "SPACE$")
                arg=$(evaluate_expression "$arg")
                str_space "$arg"
                return
                ;;
            "TAB")
                arg=$(evaluate_expression "$arg")
                str_tab "$arg"
                return
                ;;
            *)
                # Not a known function, might be an array - fall through to array handling
                ;;
        esac
    fi
    
    # Handle array access (after function calls)
    local array_regex='^([A-Z][A-Z0-9_]*)\(([^)]+)\)$'
    if [[ "$expr" =~ $array_regex ]]; then
        local array_name="${BASH_REMATCH[1]}"
        local index_expr="${BASH_REMATCH[2]}"
        
        # Evaluate the index expression
        local index=$(evaluate_expression "$index_expr")
        
        # Check if array exists
        if [[ -z "${ARRAYS[$array_name]:-}" ]]; then
            error "Array not declared: $array_name"
        fi
        
        # Get array type and size
        local array_info="${ARRAYS[$array_name]}"
        local array_type="${array_info%:*}"
        local array_size="${array_info#*:}"
        
        # Check bounds
        if [[ $index -lt 0 || $index -gt $array_size ]]; then
            error "Array index out of bounds: $array_name($index)"
        fi
        
        # Return array element value
        local element_name="${array_name}_${index}"
        if [[ "$array_type" == "string" ]]; then
            echo "${STRING_VARS[$element_name]:-}"
        else
            echo "${NUMERIC_VARS[$element_name]:-0}"
        fi
        return
    fi
    
    # Handle MOD operator (word-based operator)
    if [[ "$expr" =~ ^([A-Z0-9_]+)\ +MOD\ +([A-Z0-9_]+)$ ]]; then
        local left="${BASH_REMATCH[1]}"
        local right="${BASH_REMATCH[2]}"
        
        left=$(trim "$left")
        right=$(trim "$right")
        left=$(evaluate_expression "$left")
        right=$(evaluate_expression "$right")
        
        echo "$((left % right))"
        return
    fi
    
    # Handle string concatenation (+ operator) with proper quote handling
    # Find the + operator that's outside quotes
    local i=0
    local in_quotes=0
    local plus_pos=-1
    
    while [[ $i -lt ${#expr} ]]; do
        local char="${expr:$i:1}"
        if [[ "$char" == "\"" ]]; then
            in_quotes=$((!in_quotes))
        elif [[ "$char" == "+" && $in_quotes -eq 0 ]]; then
            plus_pos=$i
            break
        fi
        i=$((i + 1))
    done
    
    if [[ $plus_pos -ge 0 ]]; then
        # Found + operator outside quotes
        local left="${expr:0:$plus_pos}"
        local right="${expr:$((plus_pos + 1))}"
        
        left=$(trim "$left")
        right=$(trim "$right")
        
        # Evaluate both sides
        local left_val=$(evaluate_expression "$left")
        local right_val=$(evaluate_expression "$right")
        
        # Check if this is string concatenation (not arithmetic)
        if [[ ! "$left_val" =~ ^-?[0-9]+(\.[0-9]+)?$ ]] || [[ ! "$right_val" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
            # String concatenation
            echo "${left_val}${right_val}"
            return
        fi
        # If both are numeric, fall through to arithmetic handling
    fi
    
    # Handle simple arithmetic (symbol-based operators)
    if [[ "$expr" =~ ^([A-Z0-9_]+)\ *(\+|\-|\*|/)\ *([A-Z0-9_]+)$ ]]; then
        local left="${BASH_REMATCH[1]}"
        local op="${BASH_REMATCH[2]}"
        local right="${BASH_REMATCH[3]}"
        
        left=$(trim "$left")
        right=$(trim "$right")
        left=$(evaluate_expression "$left")
        right=$(evaluate_expression "$right")
        
        case "$op" in
            "+") echo "$((left + right))" ;;
            "-") echo "$((left - right))" ;;
            "*") echo "$((left * right))" ;;
            "/") echo "$((left / right))" ;;
        esac
        return
    fi
    
    # Default: return as-is
    echo "$expr"
}

# Evaluate simple condition
evaluate_condition() {
    local condition="$1"
    local result=false
    
    if [[ "$condition" =~ ^([^<>=!]+)[[:space:]]*([<>=!]+)[[:space:]]*(.+)$ ]]; then
        local left="${BASH_REMATCH[1]}"
        local op="${BASH_REMATCH[2]}"
        local right="${BASH_REMATCH[3]}"
        
        left=$(evaluate_expression "$(trim "$left")")
        right=$(evaluate_expression "$(trim "$right")")
        
        case "$op" in
            "=")  [[ "$left" == "$right" ]] && result=true ;;
            "<>") [[ "$left" != "$right" ]] && result=true ;;
            "<")  
                # Check if both are numeric
                if [[ "$left" =~ ^-?[0-9]+(\.[0-9]+)?$ ]] && [[ "$right" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
                    [[ $left -lt $right ]] && result=true
                else
                    # String comparison (lexicographic)
                    [[ "$left" < "$right" ]] && result=true
                fi
                ;;
            ">")  
                # Check if both are numeric
                if [[ "$left" =~ ^-?[0-9]+(\.[0-9]+)?$ ]] && [[ "$right" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
                    [[ $left -gt $right ]] && result=true
                else
                    # String comparison (lexicographic)
                    [[ "$left" > "$right" ]] && result=true
                fi
                ;;
            "<=") 
                # Check if both are numeric
                if [[ "$left" =~ ^-?[0-9]+(\.[0-9]+)?$ ]] && [[ "$right" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
                    [[ $left -le $right ]] && result=true
                else
                    # String comparison (lexicographic)
                    [[ "$left" < "$right" ]] || [[ "$left" == "$right" ]] && result=true
                fi
                ;;
            ">=") 
                # Check if both are numeric
                if [[ "$left" =~ ^-?[0-9]+(\.[0-9]+)?$ ]] && [[ "$right" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
                    [[ $left -ge $right ]] && result=true
                else
                    # String comparison (lexicographic)
                    [[ "$left" > "$right" ]] || [[ "$left" == "$right" ]] && result=true
                fi
                ;;
        esac
    fi
    
    echo "$result"
}

# Evaluate compound condition with AND/OR/NOT operators
evaluate_compound_condition() {
    local condition="$1"
    
    # Handle NOT operator (highest precedence)
    if [[ "$condition" =~ ^NOT[[:space:]]+(.+)$ ]]; then
        local inner_condition="${BASH_REMATCH[1]}"
        
        # Recursively evaluate the inner condition
        local inner_result=$(evaluate_compound_condition "$inner_condition")
        
        # NOT logic: true becomes false, false becomes true
        if [[ "$inner_result" == "true" ]]; then
            echo "false"
        else
            echo "true"
        fi
        return
    fi
    
    # Handle AND operator (higher precedence)
    if [[ "$condition" =~ ^(.+)[[:space:]]+AND[[:space:]]+(.+)$ ]]; then
        local left_cond="${BASH_REMATCH[1]}"
        local right_cond="${BASH_REMATCH[2]}"
        
        # Recursively evaluate both sides
        local left_result=$(evaluate_compound_condition "$left_cond")
        local right_result=$(evaluate_compound_condition "$right_cond")
        
        if [[ "$left_result" == "true" && "$right_result" == "true" ]]; then
            echo "true"
        else
            echo "false"
        fi
        return
    fi
    
    # Handle OR operator (lower precedence)
    if [[ "$condition" =~ ^(.+)[[:space:]]+OR[[:space:]]+(.+)$ ]]; then
        local left_cond="${BASH_REMATCH[1]}"
        local right_cond="${BASH_REMATCH[2]}"
        
        # Recursively evaluate both sides
        local left_result=$(evaluate_compound_condition "$left_cond")
        local right_result=$(evaluate_compound_condition "$right_cond")
        
        if [[ "$left_result" == "true" || "$right_result" == "true" ]]; then
            echo "true"
        else
            echo "false"
        fi
        return
    fi
    
    # No logical operators - evaluate as simple condition
    evaluate_condition "$condition"
}

# ===== CONTROL MODULE =====
execute_for() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    if [[ "$stmt" =~ ^([A-Za-z][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*([^[:space:]]+)[[:space:]]+TO[[:space:]]+([^[:space:]]+)([[:space:]]+STEP[[:space:]]+([^[:space:]]+))?$ ]]; then
        local var_name="${BASH_REMATCH[1]}"
        local start_val="${BASH_REMATCH[2]}"
        local end_val="${BASH_REMATCH[3]}"
        local step_val="${BASH_REMATCH[5]:-1}"
        
        start_val=$(evaluate_expression "$start_val")
        end_val=$(evaluate_expression "$end_val")
        step_val=$(evaluate_expression "$step_val")
        
        NUMERIC_VARS["$var_name"]="$start_val"
        
        # Push FOR loop info onto stack
        # Store the FOR line so NEXT can jump back to loop body
        stack_push FOR_STACK "$var_name:$end_val:$step_val:$CURRENT_LINE"
        
        debug "FOR $var_name = $start_val TO $end_val STEP $step_val at line $CURRENT_LINE"
    else
        error "Invalid FOR statement: $stmt"
    fi
}
execute_next() {
    local stmt="$1"
    
    if [[ ${#FOR_STACK[@]} -eq 0 ]]; then
        error "NEXT without FOR"
    fi
    
    local for_info="${FOR_STACK[-1]}"
    local var_name="${for_info%%:*}"
    local rest="${for_info#*:}"
    local end_val="${rest%%:*}"
    rest="${rest#*:}"
    local step_val="${rest%%:*}"
    local for_line="${rest#*:}"
    
    # Get current variable value and increment
    local current_val="${NUMERIC_VARS[$var_name]}"
    
    # Check if we need floating point arithmetic
    if [[ "$current_val" =~ \. ]] || [[ "$step_val" =~ \. ]]; then
        # Use bc for floating point arithmetic
        local new_val=$(echo "scale=10; $current_val + $step_val" | bc -l)
        # Remove trailing zeros and decimal point if not needed
        new_val=$(echo "$new_val" | sed 's/\.0*$//')
    else
        # Use bash arithmetic for integers
        local new_val=$((current_val + step_val))
    fi
    
    NUMERIC_VARS["$var_name"]="$new_val"
    
    # Check if loop should continue
    local continue_loop=false
    
    # Check if we need floating point comparison
    if [[ "$new_val" =~ \. ]] || [[ "$end_val" =~ \. ]] || [[ "$step_val" =~ \. ]]; then
        # Use bc for floating point comparison
        local step_positive=$(echo "$step_val > 0" | bc -l)
        if [[ "$step_positive" == "1" ]]; then
            local result=$(echo "$new_val <= $end_val" | bc -l)
            [[ "$result" == "1" ]] && continue_loop=true
        else
            local result=$(echo "$new_val >= $end_val" | bc -l)
            [[ "$result" == "1" ]] && continue_loop=true
        fi
    else
        # Use bash arithmetic for integer comparison
        if [[ $step_val -gt 0 ]]; then
            [[ $new_val -le $end_val ]] && continue_loop=true
        else
            [[ $new_val -ge $end_val ]] && continue_loop=true
        fi
    fi
    
    if [[ "$continue_loop" == "true" ]]; then
        # Jump to the line AFTER the FOR statement (the loop body starts there)
        # Get the next line after FOR and set that as current
        # This way the loop body executes again without re-executing FOR
        local next_after_for=$(find_next_line "$for_line")
        if [[ -n "$next_after_for" ]]; then
            CURRENT_LINE="$next_after_for"
            debug "NEXT: Continue loop, $var_name = $new_val, jumping to line $CURRENT_LINE (after FOR at $for_line)"
        else
            error "NEXT: No line after FOR"
        fi
    else
        # Pop FOR stack and continue
        stack_pop FOR_STACK >/dev/null
        debug "NEXT: End loop, $var_name = $new_val"
    fi
}
execute_while() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    # Store the condition and current line for the loop
    # Push WHILE loop info onto stack: "condition:line_num"
    stack_push WHILE_STACK "$stmt:$CURRENT_LINE"
    
    debug "WHILE $stmt"
}
execute_wend() {
    local stmt="$1"
    
    if [[ ${#WHILE_STACK[@]} -eq 0 ]]; then
        error "WEND without WHILE"
    fi
    
    local while_info="${WHILE_STACK[-1]}"
    local condition="${while_info%:*}"
    local while_line="${while_info#*:}"
    
    # Evaluate the WHILE condition (using enhanced compound condition evaluator)
    local result=$(evaluate_compound_condition "$condition")
    
    debug "WEND: condition '$condition' evaluated to $result"
    
    if [[ "$result" == "true" ]]; then
        # Jump to the line AFTER the WHILE statement (loop body starts there)
        local next_after_while=$(find_next_line "$while_line")
        if [[ -n "$next_after_while" ]]; then
            CURRENT_LINE="$next_after_while"
            debug "WEND: Continue loop, jumping to line $CURRENT_LINE (after WHILE at $while_line)"
        else
            error "WEND: No line after WHILE"
        fi
    else
        # Pop WHILE stack and continue (same pattern as FOR/NEXT)
        stack_pop WHILE_STACK >/dev/null
        debug "WEND: End loop"
    fi
}
execute_if() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    if [[ "$stmt" =~ ^(.+)[[:space:]]+THEN[[:space:]]+(.*)$ ]]; then
        local condition="${BASH_REMATCH[1]}"
        local then_else_part="${BASH_REMATCH[2]}"
        
        # Check for ELSE clause
        local then_part=""
        local else_part=""
        
        if [[ "$then_else_part" =~ ^(.+)[[:space:]]+ELSE[[:space:]]+(.*)$ ]]; then
            then_part="${BASH_REMATCH[1]}"
            else_part="${BASH_REMATCH[2]}"
            debug "IF with ELSE: then='$then_part', else='$else_part'"
        else
            then_part="$then_else_part"
            debug "IF without ELSE: then='$then_part'"
        fi
        
        # Evaluate condition using enhanced compound condition evaluator
        local result=$(evaluate_compound_condition "$condition")
        
        debug "IF condition '$condition' evaluated to $result"
        
        if [[ "$result" == "true" ]]; then
            # Execute THEN part (reuse existing logic)
            if is_numeric "$then_part"; then
                CURRENT_LINE="$then_part"
                debug "IF: GOTO line $then_part"
            else
                execute_statement "$then_part"
            fi
        elif [[ -n "$else_part" ]]; then
            # Execute ELSE part (same logic as THEN)
            if is_numeric "$else_part"; then
                CURRENT_LINE="$else_part"
                debug "IF: ELSE GOTO line $else_part"
            else
                execute_statement "$else_part"
            fi
        fi
    else
        error "Invalid IF statement: $stmt"
    fi
}
execute_gosub() {
    local line_num="$1"
    
    if [[ -z "${PROGRAM_LINES[$line_num]:-}" ]]; then
        error "GOSUB to undefined line: $line_num"
    fi
    
    # Push return address onto stack
    local next_line=$(find_next_line "$CURRENT_LINE")
    stack_push GOSUB_STACK "$next_line"
    
    CURRENT_LINE="$line_num"
    debug "GOSUB to line $line_num, return to $next_line"
}
execute_return() {
    local return_line=$(stack_pop GOSUB_STACK)
    if [[ $? -ne 0 ]]; then
        error "RETURN without GOSUB"
    fi
    
    CURRENT_LINE="$return_line"
    debug "RETURN to line $return_line"
}

# ===== STATEMENT MODULE =====
execute_print() {
    local args="$1"
    
    if [[ -z "$args" ]]; then
        echo
        return
    fi
    
    # Split by comma or semicolon
    local output=""
    local no_newline=false
    
    # Simple parsing - handle comma and semicolon separated values
    # For single expressions, just evaluate directly
    # Check if there are separators outside string literals
    local has_separators=false
    local i=0
    local in_string=0
    while [[ $i -lt ${#args} ]]; do
        local char="${args:$i:1}"
        if [[ "$char" == '"' ]]; then
            in_string=$((!in_string))
        elif [[ ($char == "," || $char == ";") && $in_string -eq 0 ]]; then
            has_separators=true
            break
        fi
        i=$((i + 1))
    done

    if [[ "$has_separators" == "false" ]]; then
        local value=$(evaluate_expression "$args")
        echo -e "$value"
        return
    fi
    
    # For multiple expressions, use parentheses-aware parsing
    while [[ -n "$args" ]]; do
        args=$(trim "$args")
        
        # Find the next comma or semicolon that's outside parentheses
        local paren_count=0
        local i=0
        local sep_pos=-1
        local sep_char=""
        
        while [[ $i -lt ${#args} ]]; do
            local char="${args:$i:1}"
            case "$char" in
                "(") paren_count=$((paren_count + 1)) ;;
                ")") paren_count=$((paren_count - 1)) ;;
                ","|";")
                    if [[ $paren_count -eq 0 ]]; then
                        sep_pos=$i
                        sep_char="$char"
                        break
                    fi
                    ;;
            esac
            i=$((i + 1))
        done
        
        if [[ $sep_pos -ge 0 ]]; then
            # Found separator outside parentheses
            local value="${args:0:$sep_pos}"
            args="${args:$((sep_pos + 1))}"
            
            value=$(evaluate_expression "$value")
            
            if [[ "$sep_char" == "," ]]; then
                # BASIC comma formatting: align to 14-character columns
                local current_len=${#output}
                local next_column=$(((current_len / 14 + 1) * 14))
                local spaces_needed=$((next_column - current_len))
                output="${output}$(printf '%*s' $spaces_needed '')${value}"
            else
                output="${output}${value}"
                no_newline=true
            fi
        else
            # No separator found - last item
            local value=$(evaluate_expression "$args")
            output="${output}${value}"
            break
        fi
    done
    
    if [[ "$no_newline" == "true" ]]; then
        printf "%s" "$output"
    else
        echo -e "$output"
    fi
}
execute_let() {
    local stmt="$1"
    stmt=$(trim "$stmt")

    debug "execute_let called with: $stmt"

    # Handle array assignment: VARNAME(INDEX) = VALUE
    local array_assign_regex='^([A-Z][A-Z0-9_]*\$?)\(([^)]+)\)[[:space:]]*=[[:space:]]*(.*)$'
    debug "Checking array assignment regex against: $stmt"
    if [[ "$stmt" =~ $array_assign_regex ]]; then
        local array_name="${BASH_REMATCH[1]}"
        local index_expr="${BASH_REMATCH[2]}"
        local value="${BASH_REMATCH[3]}"
        debug "Array assignment matched: array_name=$array_name, index_expr=$index_expr, value=$value"
        
        # Evaluate index and value
        local index=$(evaluate_expression "$index_expr")
        value=$(evaluate_expression "$value")
        
        # Check if array exists
        if [[ -z "${ARRAYS[$array_name]:-}" ]]; then
            error "Array not declared: $array_name"
        fi
        
        # Get array info
        local array_info="${ARRAYS[$array_name]}"
        local array_type="${array_info%:*}"
        local array_size="${array_info#*:}"
        
        # Check bounds
        if [[ $index -lt 0 || $index -gt $array_size ]]; then
            error "Array index out of bounds: $array_name($index)"
        fi
        
        # Store array element
        local element_name="${array_name}_${index}"
        if [[ "$array_type" == "string" ]]; then
            STRING_VARS["$element_name"]="$value"
        else
            NUMERIC_VARS["$element_name"]="$value"
        fi
        
        debug "Set $array_name($index) = $value"
        
    # Handle regular variable assignment: VARNAME = VALUE or VARNAME% = VALUE
    elif [[ "$stmt" =~ ^([A-Z][A-Z0-9_]*\$?%?)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
        local var_name="${BASH_REMATCH[1]}"
        local value="${BASH_REMATCH[2]}"
        
        value=$(evaluate_expression "$value")
        
        if [[ "$var_name" =~ \$$ ]]; then
            STRING_VARS["$var_name"]="$value"
        elif [[ "$var_name" =~ %$ ]]; then
            # Integer variable - truncate to integer
            value=$(printf "%.0f" "$value" 2>/dev/null || echo "0")
            NUMERIC_VARS["$var_name"]="$value"
        else
            NUMERIC_VARS["$var_name"]="$value"
        fi
        
        debug "Set $var_name = $value"
    else
        error "Invalid LET statement: $stmt"
    fi
}
execute_dim() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    # Arrays are already declared during pre-parsing
    # This function exists for compatibility but does nothing
    debug "DIM statement already processed during pre-parsing: $stmt"
}
execute_input() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    local prompt=""
    local var_list=""
    
    # Parse INPUT statement: INPUT "prompt", VAR or INPUT VAR
    if [[ "$stmt" =~ ^\"([^\"]*)\",[[:space:]]*(.+)$ ]]; then
        prompt="${BASH_REMATCH[1]}"
        var_list="${BASH_REMATCH[2]}"
    elif [[ "$stmt" =~ ^\"([^\"]*)\"[[:space:]]+(.+)$ ]]; then
        prompt="${BASH_REMATCH[1]}"
        var_list="${BASH_REMATCH[2]}"
    else
        var_list="$stmt"
    fi
    
    # Display prompt if provided
    if [[ -n "$prompt" ]]; then
        printf "%s" "$prompt"
    else
        printf "? "
    fi
    
    # Read input
    local input_value
    read -r input_value
    
    # Convert to uppercase if BASHIC_UPPER_CASE mode is enabled
    # Check both environment variable and BASIC variable
    local upper_case_mode="${BASHIC_UPPER_CASE:-${NUMERIC_VARS[BASHIC_UPPER_CASE]:-0}}"
    if [[ "$upper_case_mode" == "1" ]]; then
        input_value="${input_value^^}"
    fi
    
    # Parse variable list (comma-separated)
    IFS=',' read -ra vars <<< "$var_list"
    
    if [[ ${#vars[@]} -eq 1 ]]; then
        # Single variable
        local var_name=$(trim "${vars[0]}")
        
        if [[ "$var_name" =~ \$$ ]]; then
            # String variable
            STRING_VARS["$var_name"]="$input_value"
        else
            # Numeric variable
            if [[ "$input_value" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
                NUMERIC_VARS["$var_name"]="$input_value"
            else
                NUMERIC_VARS["$var_name"]="0"
            fi
        fi
    else
        # Multiple variables - split input by comma
        IFS=',' read -ra input_vals <<< "$input_value"
        
        local idx=0
        for var_name in "${vars[@]}"; do
            var_name=$(trim "$var_name")
            local val="${input_vals[$idx]:-}"
            val=$(trim "$val")
            
            if [[ "$var_name" =~ \$$ ]]; then
                # String variable
                STRING_VARS["$var_name"]="$val"
            else
                # Numeric variable
                if [[ "$val" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
                    NUMERIC_VARS["$var_name"]="$val"
                else
                    NUMERIC_VARS["$var_name"]="0"
                fi
            fi
            idx=$((idx + 1))
        done
    fi
    
    debug "INPUT: Read values into variables"
}
execute_read() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    # Parse variable list (comma-separated)
    IFS=',' read -ra vars <<< "$stmt"
    
    for var_name in "${vars[@]}"; do
        var_name=$(trim "$var_name")
        
        # Check if we have more data
        if [[ $DATA_POINTER -ge ${#DATA_ITEMS[@]} ]]; then
            error "READ: Out of DATA"
        fi
        
        local value="${DATA_ITEMS[$DATA_POINTER]}"
        DATA_POINTER=$((DATA_POINTER + 1))
        
        # Assign to variable
        if [[ "$var_name" =~ \$$ ]]; then
            STRING_VARS["$var_name"]="$value"
        else
            NUMERIC_VARS["$var_name"]="$value"
        fi
        
        debug "READ: $var_name = $value"
    done
}
execute_restore() {
    DATA_POINTER=0
    debug "RESTORE: Data pointer reset to 0"
}
execute_randomize() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    # RANDOMIZE optionally takes a seed value
    # In bash, we can't truly set RANDOM seed, but we can note it
    if [[ -n "$stmt" ]]; then
        local seed=$(evaluate_expression "$stmt")
        debug "RANDOMIZE: Seed value $seed (noted but RANDOM is not seedable in bash)"
    else
        debug "RANDOMIZE: Using default randomization"
    fi
}
execute_statement() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    debug "Executing: $stmt"
    
    # Skip empty statements and comments
    [[ -z "$stmt" ]] && return
    [[ "$stmt" =~ ^REM ]] && return
    [[ "$stmt" =~ ^\' ]] && return
    
    # Convert to uppercase for keyword matching
    local upper_stmt="${stmt^^}"
    
    case "$upper_stmt" in
        END|STOP)
            debug "Program ended"
            RUNNING=false
            ;;
        CLS)
            screen_cls
            ;;
        LOCATE*)
            local args="${stmt#*LOCATE}"
            args=$(trim "$args")
            if [[ "$args" =~ ^([0-9]+),([0-9]+) ]]; then
                local row="${BASH_REMATCH[1]}"
                local col="${BASH_REMATCH[2]}"
                screen_locate "$row" "$col"
            fi
            ;;
        COLOR*)
            local args="${stmt#*COLOR}"
            args=$(trim "$args")
            if [[ "$args" =~ ^([0-9]+),([0-9]+) ]]; then
                local fg="${BASH_REMATCH[1]}"
                local bg="${BASH_REMATCH[2]}"
                screen_color "$fg" "$bg"
            elif [[ "$args" =~ ^([0-9]+) ]]; then
                local fg="${BASH_REMATCH[1]}"
                screen_color "$fg" "$CURRENT_BG_COLOR"
            fi
            ;;
        BEEP)
            screen_beep
            ;;
        WIDTH*)
            local args="${stmt#*WIDTH}"
            args=$(trim "$args")
            if [[ "$args" =~ ^([0-9]+) ]]; then
                screen_width "${BASH_REMATCH[1]}"
            fi
            ;;
        SCREEN*)
            local args="${stmt#*SCREEN}"
            args=$(trim "$args")
            execute_screen "$args"
            ;;
        LINE*)
            local args="${stmt#*LINE}"
            args=$(trim "$args")
            execute_line "$args"
            ;;
        KEY*|SOUND*|POKE*|PEEK*|DEF*)
            # Other GW-BASIC hardware commands - ignore (no-op stubs)
            debug "Ignoring GW-BASIC command: ${upper_stmt%% *}"
            ;;
        DATA*)
            # DATA statements are processed during pre-parsing, ignore during execution
            debug "DATA statement already processed"
            ;;
        READ*)
            local args="${stmt#*READ}"
            execute_read "$args"
            ;;
        RESTORE)
            execute_restore
            ;;
        RANDOMIZE*)
            local args="${stmt#*RANDOMIZE}"
            execute_randomize "$args"
            ;;
        ON*)
            # ON...GOTO statement: ON var GOTO line1, line2, line3
            if [[ "$upper_stmt" =~ ^ON[[:space:]]+(.+)[[:space:]]+GOTO[[:space:]]+(.+)$ ]]; then
                local var_expr="${BASH_REMATCH[1]}"
                local line_list="${BASH_REMATCH[2]}"
                
                # Evaluate the variable
                local index=$(evaluate_expression "$var_expr")
                
                # Parse comma-separated line numbers
                IFS=',' read -ra lines <<< "$line_list"
                
                # Check bounds (1-based indexing in BASIC)
                if [[ $index -lt 1 || $index -gt ${#lines[@]} ]]; then
                    debug "ON GOTO: Index $index out of range (1-${#lines[@]}), ignoring"
                else
                    local target_line=$(trim "${lines[$((index - 1))]}")
                    CURRENT_LINE="$target_line"
                    debug "ON $index GOTO $target_line"
                fi
            else
                debug "ON statement (not GOTO): ignoring"
            fi
            ;;
        PRINT*)
            local args="${stmt#*PRINT}"
            execute_print "$args"
            ;;
        LET*)
            local args="${stmt#*LET}"
            execute_let "$args"
            ;;
        DIM*)
            local args="${stmt#*DIM}"
            execute_dim "$args"
            ;;
        INPUT*)
            local args="${stmt#*INPUT}"
            execute_input "$args"
            ;;
        FOR*)
            local args="${stmt#*FOR}"
            execute_for "$args"
            ;;
        NEXT*)
            execute_next "$stmt"
            ;;
        WHILE*)
            local args="${stmt#*WHILE}"
            execute_while "$args"
            ;;
        WEND*)
            execute_wend "$stmt"
            ;;
        IF*)
            local args="${stmt#*IF}"
            execute_if "$args"
            ;;
        GOTO*)
            local line_num="${stmt#*GOTO}"
            line_num=$(trim "$line_num")
            if [[ -z "${PROGRAM_LINES[$line_num]:-}" ]]; then
                error "GOTO to undefined line: $line_num"
            fi
            CURRENT_LINE="$line_num"
            debug "GOTO line $line_num"
            ;;
        GOSUB*)
            local line_num="${stmt#*GOSUB}"
            line_num=$(trim "$line_num")
            execute_gosub "$line_num"
            ;;
        RETURN)
            execute_return
            ;;
        *)
            # Check if it's an assignment without LET
            # Pattern: VARNAME[$(INDEX)] = VALUE or VARNAME = VALUE
            # Also support integer variables with % suffix: VARNAME% = VALUE
            local assign_regex='^[A-Z][A-Z0-9_]*(\$\([^)]+\)|[A-Z0-9_]*|\$|\([^)]+\)|%)?[[:space:]]*='
            debug "Checking assignment regex against: $stmt"
            if [[ "$stmt" =~ $assign_regex ]]; then
                execute_let "$stmt"
            else
                debug "Statement does not match assignment regex: $stmt"
                error "Unknown statement: $stmt"
            fi
            ;;
    esac
}

# ===== CORE MODULE =====
#!/bin/bash
# BASHIC Core Module
# bashic.core.sh - Program management, execution loop, and main function

# Load program from file
load_program() {
    local filename="$1"
    
    if [[ ! -f "$filename" ]]; then
        error "File not found: $filename"
    fi
    
    debug "Loading program: $filename"
    
    # Set up terminal for INKEY$ handling
    if [[ -t 0 ]]; then
        debug "stdin is a terminal - setting up interactive mode"
        # Save current terminal settings
        OLD_TTY_SETTINGS=$(stty -g)
        # Set terminal to raw mode
        stty raw -echo
        
        # Function to handle cleanup
        cleanup_terminal() {
            if [[ -n "$OLD_TTY_SETTINGS" ]]; then
                debug "Restoring terminal settings"
                stty "$OLD_TTY_SETTINGS" </dev/tty 2>/dev/null || true
            fi
        }
        
        # Trap for cleanup on script exit
        trap cleanup_terminal EXIT
    else
        debug "stdin is not a terminal - reading input for buffer"
        # Read all input into buffer for non-interactive mode
        INKEY_BUFFER=$(cat)
        debug "INKEY_BUFFER filled with ${#INKEY_BUFFER} characters"
    fi
    
    # Clear existing program
    PROGRAM_LINES=()
    NUMERIC_VARS=()
    STRING_VARS=()
    ARRAYS=()
    GOSUB_STACK=()
    FOR_STACK=()
    WHILE_STACK=()
    DATA_ITEMS=()
    DATA_POINTER=0
    
    # Initialize graphics buffer
    init_graphics_buffer
    
    # Read program lines
    while IFS= read -r line; do
        # Skip empty lines and comments
        if [[ -z "$line" || "$line" =~ ^[[:space:]]*REM ]]; then
            continue
        fi
        
        # Extract line number and statement
        if [[ "$line" =~ ^[[:space:]]*([0-9]+)[[:space:]]+(.*)$ ]]; then
            local line_num="${BASH_REMATCH[1]}"
            local statement="${BASH_REMATCH[2]}"
            
            # Validate line number
            if [[ $line_num -gt $MAX_LINE_NUMBER ]]; then
                error "Line number too large: $line_num"
            fi
            
            # Check if statement contains colons (multi-statement line)
            # Don't split REM comments or strings
            local has_colon=false
            local upper_stmt="${statement^^}"
            
            if [[ ! "$upper_stmt" =~ ^REM && ! "$statement" =~ ^\' ]]; then
                # Check for colon outside of strings
                local in_string=0
                local i=0
                while [[ $i -lt ${#statement} ]]; do
                    local char="${statement:$i:1}"
                    if [[ "$char" == '"' ]]; then
                        in_string=$((1 - in_string))
                    elif [[ "$char" == ":" && $in_string -eq 0 ]]; then
                        has_colon=true
                        break
                    fi
                    i=$((i + 1))
                done
            fi
            
            # If no colon or REM, store as single statement (original behavior)
            if [[ "$has_colon" == "false" ]]; then
                PROGRAM_LINES[$line_num]="$statement"
            else
                # Split by colon, preserving colons in strings
                local stmts=()
                local current=""
                local in_string=0
                local i=0
                
                while [[ $i -lt ${#statement} ]]; do
                    local char="${statement:$i:1}"
                    if [[ "$char" == '"' ]]; then
                        in_string=$((1 - in_string))
                        current="${current}${char}"
                    elif [[ "$char" == ":" && $in_string -eq 0 ]]; then
                        if [[ -n "$current" ]]; then
                            stmts+=("$current")
                            current=""
                        fi
                    else
                        current="${current}${char}"
                    fi
                    i=$((i + 1))
                done
                [[ -n "$current" ]] && stmts+=("$current")
                
                # Store statements using fractional line numbers
                if [[ ${#stmts[@]} -gt 0 ]]; then
                    PROGRAM_LINES[$line_num]="${stmts[0]}"
                    
                    local stmt_idx=1
                    while [[ $stmt_idx -lt ${#stmts[@]} ]]; do
                        local sub_line="${line_num}.${stmt_idx}"
                        PROGRAM_LINES[$sub_line]="${stmts[$stmt_idx]}"
                        debug "Multi-statement: line $line_num part $stmt_idx stored as $sub_line"
                        stmt_idx=$((stmt_idx + 1))
                    done
                fi
            fi
        fi
    done < "$filename"
    
    if [[ ${#PROGRAM_LINES[@]} -eq 0 ]]; then
        error "No valid program lines found"
    fi
    
    # Pre-parse program for DIM and DATA statements
    pre_parse_program
    
    debug "Program loaded: ${#PROGRAM_LINES[@]} lines"
}

# Pre-parse program to handle DIM and DATA statements
pre_parse_program() {
    debug "Pre-parsing program for DIM and DATA statements"
    
    # Sort line numbers for DATA statement processing
    local sorted_lines
    readarray -t sorted_lines < <(printf '%s\n' "${!PROGRAM_LINES[@]}" | sort -n)
    
    for line_num in "${sorted_lines[@]}"; do
        local stmt="${PROGRAM_LINES[$line_num]}"
        local upper_stmt=$(echo "$stmt" | tr '[:lower:]' '[:upper:]')
        
        if [[ "$upper_stmt" =~ ^DIM[[:space:]]+(.*)$ ]]; then
            local args="${BASH_REMATCH[1]}"
            args=$(trim "$args")
            
            debug "DIM args: '$args'"
            
            # Split by comma, but only outside parentheses
            declare -a array_decls
            local current=""
            local paren_count=0
            local i=0
            
            while [[ $i -lt ${#args} ]]; do
                local char="${args:$i:1}"
                if [[ "$char" == "(" ]]; then
                    paren_count=$((paren_count + 1))
                    current="${current}${char}"
                elif [[ "$char" == ")" ]]; then
                    paren_count=$((paren_count - 1))
                    current="${current}${char}"
                elif [[ "$char" == "," && $paren_count -eq 0 ]]; then
                    array_decls+=("$current")
                    current=""
                else
                    current="${current}${char}"
                fi
                i=$((i + 1))
            done
            [[ -n "$current" ]] && array_decls+=("$current")
            
            debug "Found ${#array_decls[@]} array declarations"
            
            for array_decl in "${array_decls[@]}"; do
                array_decl=$(trim "$array_decl")
                
                debug "Parsing array declaration: '$array_decl'"
                
                # Parse DIM statement: ARRAY(SIZE) or ARRAY$(SIZE) or ARRAY(SIZE,SIZE) for 2D
                # For 2D arrays, we'll use the first dimension as size
                # SIZE can be a number or a variable name (for dynamic sizing)
                if [[ "$array_decl" =~ ^([A-Za-z][A-Za-z0-9_]*)(\$?)\(([A-Za-z0-9_%]+)([[:space:]]*,[[:space:]]*[A-Za-z0-9_%]+)?\)$ ]]; then
                    local array_name="${BASH_REMATCH[1]}"
                    local is_string="${BASH_REMATCH[2]}"
                    local size_expr="${BASH_REMATCH[3]}"
                    
                    # Evaluate size expression (could be a variable or number)
                    local size
                    if [[ "$size_expr" =~ ^[0-9]+$ ]]; then
                        size="$size_expr"
                    else
                        # Try to evaluate as variable
                        size="${NUMERIC_VARS[$size_expr]:-100}"
                    fi
                    
                    # Validate array size
                    if [[ $size -gt $MAX_ARRAY_SIZE ]]; then
                        error "Array size too large: $array_name($size)"
                    fi
                    
                    # Store array metadata
                    local array_type="numeric"
                    [[ -n "$is_string" ]] && array_type="string"
                    # Include $ in array name for string arrays for consistency
                    [[ -n "$is_string" ]] && array_name="${array_name}$"
                    ARRAYS[$array_name]="$array_type:$size"
                    
                    debug "DIM: $array_name($size) - $array_type"
                else
                    error "Invalid DIM statement: $stmt"
                fi
            done
        fi
        
        # Parse DATA statements
        if [[ "$upper_stmt" =~ ^DATA[[:space:]]+(.*)$ ]]; then
            local data_args="${BASH_REMATCH[1]}"
            
            # Split by comma, preserving quoted strings
            local in_quotes=0
            local current=""
            local i=0
            
            while [[ $i -lt ${#data_args} ]]; do
                local char="${data_args:$i:1}"
                if [[ "$char" == '"' ]]; then
                    in_quotes=$((1 - in_quotes))
                    current="${current}${char}"
                elif [[ "$char" == "," && $in_quotes -eq 0 ]]; then
                    current=$(trim "$current")
                    # Remove quotes if present
                    if [[ "$current" =~ ^\"(.*)\"$ ]]; then
                        current="${BASH_REMATCH[1]}"
                    fi
                    DATA_ITEMS+=("$current")
                    current=""
                else
                    current="${current}${char}"
                fi
                i=$((i + 1))
            done
            
            # Add last item
            if [[ -n "$current" ]]; then
                current=$(trim "$current")
                if [[ "$current" =~ ^\"(.*)\"$ ]]; then
                    current="${BASH_REMATCH[1]}"
                fi
                DATA_ITEMS+=("$current")
            fi
            
            debug "DATA: Added ${#DATA_ITEMS[@]} total items so far"
        fi
    done
    
    debug "Pre-parsing complete: ${#ARRAYS[@]} arrays declared, ${#DATA_ITEMS[@]} DATA items"
}

# Get sorted line numbers
get_line_numbers() {
    if [[ -z "${SORTED_LINE_NUMBERS:-}" ]] || [[ ${#SORTED_LINE_NUMBERS[@]} -eq 0 ]]; then
        readarray -t SORTED_LINE_NUMBERS < <(printf '%s\n' "${!PROGRAM_LINES[@]}" | sort -n)
    fi
    
    printf '%s\n' "${SORTED_LINE_NUMBERS[@]}"
}

# Find next line number after current line
find_next_line() {
    local current="$1"
    local line_numbers
    readarray -t line_numbers < <(get_line_numbers)
    
    # Since lines are already sorted numerically (sort -n handles decimals)
    # we just need to find the first line after current
    local next=""
    local found_current=false
    
    for line in "${line_numbers[@]}"; do
        if [[ "$found_current" == "true" ]]; then
            next="$line"
            break
        fi
        if [[ "$line" == "$current" ]]; then
            found_current=true
        fi
    done
    
    echo "$next"
}

# Run program
run_program() {
    debug "Starting program execution"
    
    RUNNING=true
    CURRENT_LINE=0
    
    # Start with first line
    local line_numbers
    readarray -t line_numbers < <(get_line_numbers)
    
    if [[ ${#line_numbers[@]} -eq 0 ]]; then
        error "No program lines to execute"
    fi
    
    CURRENT_LINE="${line_numbers[0]}"
    
    while [[ "$RUNNING" == "true" ]]; do
        local stmt="${PROGRAM_LINES[$CURRENT_LINE]}"
        local saved_line="$CURRENT_LINE"
        
        debug "Executing line $CURRENT_LINE: $stmt"
        
        execute_statement "$stmt"
        
        if [[ "$RUNNING" == "true" ]]; then
            # Check if statement changed the line (GOTO, ON GOTO, etc.)
            if [[ "$CURRENT_LINE" != "$saved_line" ]]; then
                # Line was changed by control flow - use new line on next iteration
                debug "Control flow changed line from $saved_line to $CURRENT_LINE"
            else
                # Normal flow - advance to next line
                local next_line=$(find_next_line "$CURRENT_LINE")
                if [[ -n "$next_line" ]]; then
                    CURRENT_LINE="$next_line"
                else
                    RUNNING=false
                fi
            fi
        fi
    done
    
    debug "Program execution completed"
    
    # Restore terminal settings if we were in interactive mode
    if [[ -t 0 && -n "${saved_stty:-}" ]]; then
        debug "Restoring terminal settings"
        stty "$saved_stty" 2>/dev/null || true
    fi
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--debug)
                DEBUG=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                echo "BASHIC Version 1.0"
                exit 0
                ;;
            -*)
                error "Unknown option: $1"
                ;;
            *)
                if [[ -z "${PROGRAM_FILE:-}" ]]; then
                    PROGRAM_FILE="$1"
                else
                    error "Multiple program files specified"
                fi
                shift
                ;;
        esac
    done
}

# Main function
main() {
    parse_args "$@"
    
    if [[ -z "${PROGRAM_FILE:-}" ]]; then
        usage
        exit 1
    fi
    
    load_program "$PROGRAM_FILE"
    run_program
}

# Run main function with all arguments
main "$@"