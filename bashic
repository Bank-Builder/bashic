#!/bin/bash

# BASHIC - BASIC Interpreter in Bash
# Version 1.0
# A complete BASIC interpreter written entirely in bash

set -euo pipefail

# Constants
readonly MAX_ARRAY_SIZE=10000
readonly BASIC_INDEX_BASE=1  # BASIC uses 1-based indexing
readonly MAX_LINE_NUMBER=99999

# Global variables
declare -A PROGRAM_LINES      # Program lines indexed by line number
declare -A NUMERIC_VARS       # Numeric variables
declare -A STRING_VARS        # String variables  
declare -A ARRAYS            # Arrays
declare -a GOSUB_STACK       # GOSUB return stack
declare -a FOR_STACK         # FOR loop stack
declare -a WHILE_STACK       # WHILE loop stack

CURRENT_LINE=0
PROGRAM_COUNTER=0
RUNNING=false
DEBUG=false

# Error handling with context
error_with_context() {
    local message="$1"
    local context=""
    
    if [[ $CURRENT_LINE -gt 0 ]]; then
        context=" (line $CURRENT_LINE"
        if [[ -n "${PROGRAM_LINES[$CURRENT_LINE]:-}" ]]; then
            context="$context: ${PROGRAM_LINES[$CURRENT_LINE]}"
        fi
        context="$context)"
    fi
    
    echo "ERROR: $message$context" >&2
    exit 1
}

# Legacy error function for backward compatibility
error() {
    error_with_context "$1"
}

# Usage information
usage() {
    echo "BASHIC - BASIC Interpreter v1.0"
    echo "Usage: $0 [options] program.bas"
    echo "Options:"
    echo "  -h, --help     Show this help"
    echo "  -v, --version  Show version"
    echo "  -d, --debug    Enable debug mode"
    echo ""
    echo "Example: $0 examples/test1.bas"
}

version() {
    echo "BASHIC 1.0 - BASIC Interpreter in Bash"
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                version
                exit 0
                ;;
            -d|--debug)
                DEBUG=true
                shift
                ;;
            -*)
                error "Unknown option: $1"
                ;;
            *)
                if [[ -n "${PROGRAM_FILE:-}" ]]; then
                    error "Multiple program files specified"
                fi
                PROGRAM_FILE="$1"
                shift
                ;;
        esac
    done
}

# Debug output
debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo "DEBUG: $1" >&2
    fi
}

# Pre-parse program to extract DIM statements and validate array bounds
pre_parse_program() {
    debug "Pre-parsing program for array declarations"
    
    local line_num
    local line_content
    
    while read -r line_num; do
        line_content="${PROGRAM_LINES[$line_num]}"
        
        # Check for DIM statements
        if [[ "$line_content" =~ ^DIM[[:space:]]+(.*)$ ]]; then
            local dim_stmt="${BASH_REMATCH[1]}"
            dim_stmt=$(trim "$dim_stmt")
            
            if [[ "$dim_stmt" =~ ^([A-Z][A-Z0-9_]*\$?)\(([0-9]+)\)$ ]]; then
                local var_name="${BASH_REMATCH[1]}"
                local array_size="${BASH_REMATCH[2]}"
                
                # Validate array size
                if [[ $array_size -lt 0 ]]; then
                    error "Line $line_num: Array size cannot be negative: $var_name($array_size)"
                fi
                
                if [[ $array_size -gt $MAX_ARRAY_SIZE ]]; then
                    error "Line $line_num: Array size too large (max $MAX_ARRAY_SIZE): $var_name($array_size)"
                fi
                
                # Store array metadata
                if [[ "$var_name" =~ \$$ ]]; then
                    ARRAYS["$var_name"]="string:$array_size"
                else
                    ARRAYS["$var_name"]="numeric:$array_size"
                fi
                
                debug "Pre-parsed DIM $var_name($array_size)"
            else
                error "Line $line_num: Invalid DIM statement: $dim_stmt"
            fi
        fi
    done < <(get_line_numbers)
    
    local array_count=0
    if [[ -n "${ARRAYS:-}" ]]; then
        array_count=${#ARRAYS[@]}
    fi
    debug "Pre-parsing completed: $array_count arrays declared"
}

# Load BASIC program from file
load_program() {
    local file="$1"
    
    if [[ ! -f "$file" ]]; then
        error "Program file not found: $file"
    fi
    
    debug "Loading program: $file"
    
    local line_num
    local line_content
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments that don't start with line numbers
        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^[[:space:]]*$ ]] && continue
        
        # Extract line number and content
        if [[ "$line" =~ ^[[:space:]]*([0-9]+)[[:space:]]+(.*)$ ]]; then
            line_num="${BASH_REMATCH[1]}"
            line_content="${BASH_REMATCH[2]}"
            PROGRAM_LINES[$line_num]="$line_content"
            debug "Loaded line $line_num: $line_content"
        else
            # Lines without numbers are ignored in file mode
            debug "Ignoring line without number: $line"
        fi
    done < "$file"
    
    if [[ ${#PROGRAM_LINES[@]} -eq 0 ]]; then
        error "No valid program lines found in $file"
    fi
    
    debug "Loaded ${#PROGRAM_LINES[@]} program lines"
    
    # Pre-parse program to extract DIM statements
    pre_parse_program
}

# Global variable for sorted line numbers (cached)
declare -a SORTED_LINE_NUMBERS

# Get sorted line numbers (cached)
get_line_numbers() {
    if [[ -z "${SORTED_LINE_NUMBERS:-}" ]] || [[ ${#SORTED_LINE_NUMBERS[@]} -eq 0 ]]; then
        readarray -t SORTED_LINE_NUMBERS < <(printf '%s\n' "${!PROGRAM_LINES[@]}" | sort -n)
    fi
    printf '%s\n' "${SORTED_LINE_NUMBERS[@]}"
}

# Find next line number after current (optimized with binary search)
find_next_line() {
    local current="$1"
    local next=""
    
    # Ensure sorted line numbers are cached
    get_line_numbers >/dev/null
    
    # Binary search for next line
    local left=0
    local right=$((${#SORTED_LINE_NUMBERS[@]} - 1))
    
    while [[ $left -le $right ]]; do
        local mid=$(( (left + right) / 2 ))
        local mid_line="${SORTED_LINE_NUMBERS[$mid]}"
        
        if [[ $mid_line -gt $current ]]; then
            next="$mid_line"
            right=$((mid - 1))
        else
            left=$((mid + 1))
        fi
    done
    
    echo "$next"
}

# Trim whitespace
trim() {
    local var="$1"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    echo "$var"
}

# Check if string is numeric
is_numeric() {
    local str="$1"
    [[ "$str" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]
}

# Mathematical functions
math_abs() {
    local n="$1"
    if [[ $(echo "$n < 0" | bc -l 2>/dev/null || echo "0") == "1" ]]; then
        echo "$n * -1" | bc -l 2>/dev/null || echo "${n#-}"
    else
        echo "$n"
    fi
}

math_int() {
    local n="$1"
    echo "$n" | cut -d. -f1
}

math_sgn() {
    local n="$1"
    if [[ "$n" =~ ^-.*$ ]]; then
        echo "-1"
    elif [[ "$n" == "0" || "$n" == "0.0" ]]; then
        echo "0"
    else
        echo "1"
    fi
}

math_sqr() {
    local n="$1"
    # Simple square root using bash arithmetic (limited precision)
    if command -v bc >/dev/null 2>&1; then
        echo "sqrt($n)" | bc -l
    else
        # Fallback: Newton's method approximation
        local x="$n"
        local prev=0
        while [[ "$x" != "$prev" ]]; do
            prev="$x"
            x=$(( (x + n/x) / 2 ))
        done
        echo "$x"
    fi
}

# String functions
str_len() {
    echo "${#1}"
}

str_left() {
    local str="$1"
    local len="$2"
    echo "${str:0:$len}"
}

str_right() {
    local str="$1"
    local len="$2"
    local str_len="${#str}"
    local start=$((str_len - len))
    [[ $start -lt 0 ]] && start=0
    echo "${str:$start}"
}

str_mid() {
    local str="$1"
    local start="$2"
    local len="${3:-${#str}}"
    start=$((start - BASIC_INDEX_BASE))  # BASIC uses 1-based indexing
    [[ $start -lt 0 ]] && start=0
    echo "${str:$start:$len}"
}

str_asc() {
    local str="$1"
    [[ -z "$str" ]] && echo "0" && return
    printf "%d" "'${str:0:1}"
}

str_chr() {
    local code="$1"
    printf "\\$(printf "%03o" "$code")"
}

str_val() {
    local str="$1"
    # Extract numeric part from beginning of string
    if [[ "$str" =~ ^[[:space:]]*(-?[0-9]+(\.[0-9]+)?) ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo "0"
    fi
}

# Evaluate expression (optimized with single regex pattern)
evaluate_expression() {
    local expr="$1"
    expr=$(trim "$expr")
    
    debug "Evaluating expression: $expr"
    
    # Handle string literals
    if [[ "$expr" =~ ^\"(.*)\"$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return
    fi
    
    # Handle string variables
    if [[ "$expr" =~ ^[A-Z][A-Z0-9_]*\$$ ]]; then
        local var_name="$expr"
        echo "${STRING_VARS[$var_name]:-}"
        return
    fi
    
    # Handle numeric variables
    if [[ "$expr" =~ ^[A-Z][A-Z0-9_]*$ ]]; then
        local var_name="$expr"
        echo "${NUMERIC_VARS[$var_name]:-0}"
        return
    fi
    
    # Handle numeric literals
    if is_numeric "$expr"; then
        echo "$expr"
        return
    fi
    
    # Handle function calls (check before array access)
    local func_regex='^([A-Z]+\$?)\(([^)]*)\)$'
    if [[ "$expr" =~ $func_regex ]]; then
        local func="${BASH_REMATCH[1]}"
        local arg="${BASH_REMATCH[2]}"
        
        # Check if it's a known function (not an array)
        case "$func" in
            "ABS")
                arg=$(evaluate_expression "$arg")
                math_abs "$arg"
                return
                ;;
            "INT")
                arg=$(evaluate_expression "$arg")
                math_int "$arg"
                return
                ;;
            "SGN")
                arg=$(evaluate_expression "$arg")
                math_sgn "$arg"
                return
                ;;
            "SQR")
                arg=$(evaluate_expression "$arg")
                math_sqr "$arg"
                return
                ;;
            "LEN")
                arg=$(evaluate_expression "$arg")
                str_len "$arg"
                return
                ;;
            "LEFT$")
                if [[ "$arg" =~ ^([^,]+),([^,]+)$ ]]; then
                    local str_arg="${BASH_REMATCH[1]}"
                    local len_arg="${BASH_REMATCH[2]}"
                    str_arg=$(evaluate_expression "$(trim "$str_arg")")
                    len_arg=$(evaluate_expression "$(trim "$len_arg")")
                    str_left "$str_arg" "$len_arg"
                    return
                fi
                ;;
            "RIGHT$")
                if [[ "$arg" =~ ^([^,]+),([^,]+)$ ]]; then
                    local str_arg="${BASH_REMATCH[1]}"
                    local len_arg="${BASH_REMATCH[2]}"
                    str_arg=$(evaluate_expression "$(trim "$str_arg")")
                    len_arg=$(evaluate_expression "$(trim "$len_arg")")
                    str_right "$str_arg" "$len_arg"
                    return
                fi
                ;;
            "MID$")
                if [[ "$arg" =~ ^([^,]+),([^,]+),([^,]+)$ ]]; then
                    local str_arg="${BASH_REMATCH[1]}"
                    local start_arg="${BASH_REMATCH[2]}"
                    local len_arg="${BASH_REMATCH[3]}"
                    str_arg=$(evaluate_expression "$(trim "$str_arg")")
                    start_arg=$(evaluate_expression "$(trim "$start_arg")")
                    len_arg=$(evaluate_expression "$(trim "$len_arg")")
                    str_mid "$str_arg" "$start_arg" "$len_arg"
                    return
                fi
                ;;
            "ASC")
                arg=$(evaluate_expression "$arg")
                str_asc "$arg"
                return
                ;;
            "CHR$")
                arg=$(evaluate_expression "$arg")
                str_chr "$arg"
                return
                ;;
            "VAL")
                arg=$(evaluate_expression "$arg")
                str_val "$arg"
                return
                ;;
            "STR$")
                arg=$(evaluate_expression "$arg")
                echo "$arg"
                return
                ;;
            *)
                # Not a known function, might be an array - fall through to array handling
                ;;
        esac
    fi
    
    # Handle array access (after function calls)
    local array_regex='^([A-Z][A-Z0-9_]*)\(([^)]+)\)$'
    if [[ "$expr" =~ $array_regex ]]; then
        local array_name="${BASH_REMATCH[1]}"
        local index_expr="${BASH_REMATCH[2]}"
        
        # Evaluate the index expression
        local index=$(evaluate_expression "$index_expr")
        
        # Check if array exists
        if [[ -z "${ARRAYS[$array_name]:-}" ]]; then
            error "Array not declared: $array_name"
        fi
        
        # Get array type and size
        local array_info="${ARRAYS[$array_name]}"
        local array_type="${array_info%:*}"
        local array_size="${array_info#*:}"
        
        # Check bounds
        if [[ $index -lt 0 || $index -gt $array_size ]]; then
            error "Array index out of bounds: $array_name($index)"
        fi
        
        # Return array element value
        local element_name="${array_name}_${index}"
        if [[ "$array_type" == "string" ]]; then
            echo "${STRING_VARS[$element_name]:-}"
        else
            echo "${NUMERIC_VARS[$element_name]:-0}"
        fi
        return
    fi
    
    # Handle MOD operator (word-based operator)
    if [[ "$expr" =~ ^([A-Z0-9_]+)\ +MOD\ +([A-Z0-9_]+)$ ]]; then
        local left="${BASH_REMATCH[1]}"
        local right="${BASH_REMATCH[2]}"
        
        left=$(trim "$left")
        right=$(trim "$right")
        left=$(evaluate_expression "$left")
        right=$(evaluate_expression "$right")
        
        echo "$((left % right))"
        return
    fi
    
    # Handle string concatenation (+ operator) with proper quote handling
    # Find the + operator that's outside quotes
    local i=0
    local in_quotes=false
    local plus_pos=-1
    
    while [[ $i -lt ${#expr} ]]; do
        local char="${expr:$i:1}"
        if [[ "$char" == "\"" ]]; then
            in_quotes=$((!in_quotes))
        elif [[ "$char" == "+" && "$in_quotes" == "false" ]]; then
            plus_pos=$i
            break
        fi
        i=$((i + 1))
    done
    
    if [[ $plus_pos -ge 0 ]]; then
        # Found + operator outside quotes
        local left="${expr:0:$plus_pos}"
        local right="${expr:$((plus_pos + 1))}"
        
        left=$(trim "$left")
        right=$(trim "$right")
        
        # Evaluate both sides
        local left_val=$(evaluate_expression "$left")
        local right_val=$(evaluate_expression "$right")
        
        # Check if this is string concatenation (not arithmetic)
        if [[ ! "$left_val" =~ ^-?[0-9]+(\.[0-9]+)?$ ]] || [[ ! "$right_val" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
            # String concatenation
            echo "${left_val}${right_val}"
            return
        fi
        # If both are numeric, fall through to arithmetic handling
    fi
    
    # Handle simple arithmetic (symbol-based operators)
    if [[ "$expr" =~ ^([A-Z0-9_]+)\ *(\+|\-|\*|/)\ *([A-Z0-9_]+)$ ]]; then
        local left="${BASH_REMATCH[1]}"
        local op="${BASH_REMATCH[2]}"
        local right="${BASH_REMATCH[3]}"
        
        left=$(trim "$left")
        right=$(trim "$right")
        left=$(evaluate_expression "$left")
        right=$(evaluate_expression "$right")
        
        case "$op" in
            "+") echo "$((left + right))" ;;
            "-") echo "$((left - right))" ;;
            "*") echo "$((left * right))" ;;
            "/") echo "$((left / right))" ;;
        esac
        return
    fi
    
    # Default: return as-is
    echo "$expr"
}

# Execute PRINT statement
execute_print() {
    local args="$1"
    
    if [[ -z "$args" ]]; then
        echo
        return
    fi
    
    # Split by comma or semicolon
    local output=""
    local no_newline=false
    
    # Simple parsing - handle comma and semicolon separated values
    # For single expressions, just evaluate directly
    if [[ "$args" != *","* && "$args" != *";"* ]]; then
        local value=$(evaluate_expression "$args")
        echo -e "$value"
        return
    fi
    
    # For multiple expressions, use parentheses-aware parsing
    while [[ -n "$args" ]]; do
        args=$(trim "$args")
        
        # Find the next comma or semicolon that's outside parentheses
        local paren_count=0
        local i=0
        local sep_pos=-1
        local sep_char=""
        
        while [[ $i -lt ${#args} ]]; do
            local char="${args:$i:1}"
            case "$char" in
                "(") paren_count=$((paren_count + 1)) ;;
                ")") paren_count=$((paren_count - 1)) ;;
                ","|";")
                    if [[ $paren_count -eq 0 ]]; then
                        sep_pos=$i
                        sep_char="$char"
                        break
                    fi
                    ;;
            esac
            i=$((i + 1))
        done
        
        if [[ $sep_pos -ge 0 ]]; then
            # Found separator outside parentheses
            local value="${args:0:$sep_pos}"
            args="${args:$((sep_pos + 1))}"
            
            value=$(evaluate_expression "$value")
            
            if [[ "$sep_char" == "," ]]; then
                output="${output}${value}\t"
            else
                output="${output}${value}"
                no_newline=true
            fi
        else
            # No separator found - last item
            local value=$(evaluate_expression "$args")
            output="${output}${value}"
            break
        fi
    done
    
    if [[ "$no_newline" == "true" ]]; then
        printf "%s" "$output"
    else
        echo -e "$output"
    fi
}

# Execute LET statement
execute_let() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    # Handle array assignment: VARNAME(INDEX) = VALUE
    local array_assign_regex='^([A-Z][A-Z0-9_]*)\(([^)]+)\)[[:space:]]*=[[:space:]]*(.*)$'
    if [[ "$stmt" =~ $array_assign_regex ]]; then
        local array_name="${BASH_REMATCH[1]}"
        local index_expr="${BASH_REMATCH[2]}"
        local value="${BASH_REMATCH[3]}"
        
        # Evaluate index and value
        local index=$(evaluate_expression "$index_expr")
        value=$(evaluate_expression "$value")
        
        # Check if array exists
        if [[ -z "${ARRAYS[$array_name]:-}" ]]; then
            error "Array not declared: $array_name"
        fi
        
        # Get array info
        local array_info="${ARRAYS[$array_name]}"
        local array_type="${array_info%:*}"
        local array_size="${array_info#*:}"
        
        # Check bounds
        if [[ $index -lt 0 || $index -gt $array_size ]]; then
            error "Array index out of bounds: $array_name($index)"
        fi
        
        # Store array element
        local element_name="${array_name}_${index}"
        if [[ "$array_type" == "string" ]]; then
            STRING_VARS["$element_name"]="$value"
        else
            NUMERIC_VARS["$element_name"]="$value"
        fi
        
        debug "Set $array_name($index) = $value"
        
    # Handle regular variable assignment: VARNAME = VALUE
    elif [[ "$stmt" =~ ^([A-Z][A-Z0-9_]*\$?)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
        local var_name="${BASH_REMATCH[1]}"
        local value="${BASH_REMATCH[2]}"
        
        value=$(evaluate_expression "$value")
        
        if [[ "$var_name" =~ \$$ ]]; then
            STRING_VARS["$var_name"]="$value"
        else
            NUMERIC_VARS["$var_name"]="$value"
        fi
        
        debug "Set $var_name = $value"
    else
        error "Invalid LET statement: $stmt"
    fi
}

# Execute DIM statement (arrays already declared in pre-parsing)
execute_dim() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    # Arrays are already declared during pre-parsing
    # This function exists for compatibility but does nothing
    debug "DIM statement already processed during pre-parsing: $stmt"
}

# Execute FOR statement
execute_for() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    if [[ "$stmt" =~ ^([A-Z][A-Z0-9_]*)[[:space:]]*=[[:space:]]*([^[:space:]]+)[[:space:]]+TO[[:space:]]+([^[:space:]]+)([[:space:]]+STEP[[:space:]]+([^[:space:]]+))?$ ]]; then
        local var_name="${BASH_REMATCH[1]}"
        local start_val="${BASH_REMATCH[2]}"
        local end_val="${BASH_REMATCH[3]}"
        local step_val="${BASH_REMATCH[5]:-1}"
        
        start_val=$(evaluate_expression "$start_val")
        end_val=$(evaluate_expression "$end_val")
        step_val=$(evaluate_expression "$step_val")
        
        NUMERIC_VARS["$var_name"]="$start_val"
        
        # Push FOR loop info onto stack
        stack_push FOR_STACK "$var_name:$end_val:$step_val:$CURRENT_LINE"
        
        debug "FOR $var_name = $start_val TO $end_val STEP $step_val"
    else
        error "Invalid FOR statement: $stmt"
    fi
}

# Execute NEXT statement
execute_next() {
    local stmt="$1"
    
    if [[ ${#FOR_STACK[@]} -eq 0 ]]; then
        error "NEXT without FOR"
    fi
    
    local for_info="${FOR_STACK[-1]}"
    local var_name="${for_info%%:*}"
    local rest="${for_info#*:}"
    local end_val="${rest%%:*}"
    rest="${rest#*:}"
    local step_val="${rest%%:*}"
    local for_line="${rest#*:}"
    
    # Get current variable value and increment
    local current_val="${NUMERIC_VARS[$var_name]}"
    local new_val=$((current_val + step_val))
    NUMERIC_VARS["$var_name"]="$new_val"
    
    # Check if loop should continue
    local continue_loop=false
    if [[ $step_val -gt 0 ]]; then
        [[ $new_val -le $end_val ]] && continue_loop=true
    else
        [[ $new_val -ge $end_val ]] && continue_loop=true
    fi
    
    if [[ "$continue_loop" == "true" ]]; then
        CURRENT_LINE="$for_line"
        debug "NEXT: Continue loop, $var_name = $new_val, jumping to line $for_line"
    else
        # Pop FOR stack and continue
        stack_pop FOR_STACK >/dev/null
        debug "NEXT: End loop, $var_name = $new_val"
    fi
}

# Generic stack management functions
stack_push() {
    local -n stack_ref="$1"
    local value="$2"
    stack_ref+=("$value")
}

stack_pop() {
    local -n stack_ref="$1"
    if [[ ${#stack_ref[@]} -eq 0 ]]; then
        return 1
    fi
    local last_index=$((${#stack_ref[@]} - 1))
    local value="${stack_ref[$last_index]}"
    unset stack_ref[$last_index]
    stack_ref=("${stack_ref[@]}")
    echo "$value"
}

# Evaluate a single condition (shared helper for IF and WHILE)
evaluate_condition() {
    local condition="$1"
    local result=false
    
    if [[ "$condition" =~ ^([^<>=!]+)[[:space:]]*([<>=!]+)[[:space:]]*(.+)$ ]]; then
        local left="${BASH_REMATCH[1]}"
        local op="${BASH_REMATCH[2]}"
        local right="${BASH_REMATCH[3]}"
        
        left=$(evaluate_expression "$(trim "$left")")
        right=$(evaluate_expression "$(trim "$right")")
        
        case "$op" in
            "=")  [[ "$left" == "$right" ]] && result=true ;;
            "<>") [[ "$left" != "$right" ]] && result=true ;;
            "<")  [[ $left -lt $right ]] && result=true ;;
            ">")  [[ $left -gt $right ]] && result=true ;;
            "<=") [[ $left -le $right ]] && result=true ;;
            ">=") [[ $left -ge $right ]] && result=true ;;
        esac
    fi
    
    echo "$result"
}

# Evaluate compound condition with AND/OR/NOT operators
evaluate_compound_condition() {
    local condition="$1"
    
    # Handle NOT operator (highest precedence)
    if [[ "$condition" =~ ^NOT[[:space:]]+(.+)$ ]]; then
        local inner_condition="${BASH_REMATCH[1]}"
        
        # Recursively evaluate the inner condition
        local inner_result=$(evaluate_compound_condition "$inner_condition")
        
        # NOT logic: true becomes false, false becomes true
        if [[ "$inner_result" == "true" ]]; then
            echo "false"
        else
            echo "true"
        fi
        return
    fi
    
    # Handle AND operator (higher precedence)
    if [[ "$condition" =~ ^(.+)[[:space:]]+AND[[:space:]]+(.+)$ ]]; then
        local left_cond="${BASH_REMATCH[1]}"
        local right_cond="${BASH_REMATCH[2]}"
        
        # Recursively evaluate both sides
        local left_result=$(evaluate_compound_condition "$left_cond")
        local right_result=$(evaluate_compound_condition "$right_cond")
        
        if [[ "$left_result" == "true" && "$right_result" == "true" ]]; then
            echo "true"
        else
            echo "false"
        fi
        return
    fi
    
    # Handle OR operator (lower precedence)
    if [[ "$condition" =~ ^(.+)[[:space:]]+OR[[:space:]]+(.+)$ ]]; then
        local left_cond="${BASH_REMATCH[1]}"
        local right_cond="${BASH_REMATCH[2]}"
        
        # Recursively evaluate both sides
        local left_result=$(evaluate_compound_condition "$left_cond")
        local right_result=$(evaluate_compound_condition "$right_cond")
        
        if [[ "$left_result" == "true" || "$right_result" == "true" ]]; then
            echo "true"
        else
            echo "false"
        fi
        return
    fi
    
    # No logical operators - evaluate as simple condition
    evaluate_condition "$condition"
}

# Execute WHILE statement
execute_while() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    # Store the condition and current line for the loop
    # Push WHILE loop info onto stack: "condition:line_num"
    stack_push WHILE_STACK "$stmt:$CURRENT_LINE"
    
    debug "WHILE $stmt"
}

# Execute WEND statement  
execute_wend() {
    local stmt="$1"
    
    if [[ ${#WHILE_STACK[@]} -eq 0 ]]; then
        error "WEND without WHILE"
    fi
    
    local while_info="${WHILE_STACK[-1]}"
    local condition="${while_info%:*}"
    local while_line="${while_info#*:}"
    
    # Evaluate the WHILE condition (using enhanced compound condition evaluator)
    local result=$(evaluate_compound_condition "$condition")
    
    debug "WEND: condition '$condition' evaluated to $result"
    
    if [[ "$result" == "true" ]]; then
        CURRENT_LINE="$while_line"
        debug "WEND: Continue loop, jumping to line $while_line"
    else
        # Pop WHILE stack and continue (same pattern as FOR/NEXT)
        stack_pop WHILE_STACK >/dev/null
        debug "WEND: End loop"
    fi
}

# Execute IF statement
execute_if() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    if [[ "$stmt" =~ ^(.+)[[:space:]]+THEN[[:space:]]+(.*)$ ]]; then
        local condition="${BASH_REMATCH[1]}"
        local then_else_part="${BASH_REMATCH[2]}"
        
        # Check for ELSE clause
        local then_part=""
        local else_part=""
        
        if [[ "$then_else_part" =~ ^(.+)[[:space:]]+ELSE[[:space:]]+(.*)$ ]]; then
            then_part="${BASH_REMATCH[1]}"
            else_part="${BASH_REMATCH[2]}"
            debug "IF with ELSE: then='$then_part', else='$else_part'"
        else
            then_part="$then_else_part"
            debug "IF without ELSE: then='$then_part'"
        fi
        
        # Evaluate condition using enhanced compound condition evaluator
        local result=$(evaluate_compound_condition "$condition")
        
        debug "IF condition '$condition' evaluated to $result"
        
        if [[ "$result" == "true" ]]; then
            # Execute THEN part (reuse existing logic)
            if is_numeric "$then_part"; then
                CURRENT_LINE="$then_part"
                debug "IF: GOTO line $then_part"
            else
                execute_statement "$then_part"
            fi
        elif [[ -n "$else_part" ]]; then
            # Execute ELSE part (same logic as THEN)
            if is_numeric "$else_part"; then
                CURRENT_LINE="$else_part"
                debug "IF: ELSE GOTO line $else_part"
            else
                execute_statement "$else_part"
            fi
        fi
    else
        error "Invalid IF statement: $stmt"
    fi
}

# Execute GOSUB statement
execute_gosub() {
    local line_num="$1"
    
    if [[ -z "${PROGRAM_LINES[$line_num]:-}" ]]; then
        error "GOSUB to undefined line: $line_num"
    fi
    
    # Push return address onto stack
    local next_line=$(find_next_line "$CURRENT_LINE")
    stack_push GOSUB_STACK "$next_line"
    
    CURRENT_LINE="$line_num"
    debug "GOSUB to line $line_num, return to $next_line"
}

# Execute RETURN statement
execute_return() {
    local return_line=$(stack_pop GOSUB_STACK)
    if [[ $? -ne 0 ]]; then
        error "RETURN without GOSUB"
    fi
    
    CURRENT_LINE="$return_line"
    debug "RETURN to line $return_line"
}

# Execute statement
execute_statement() {
    local stmt="$1"
    stmt=$(trim "$stmt")
    
    debug "Executing: $stmt"
    
    # Skip empty statements and comments
    [[ -z "$stmt" ]] && return
    [[ "$stmt" =~ ^REM ]] && return
    [[ "$stmt" =~ ^\' ]] && return
    
    # Convert to uppercase for keyword matching
    local upper_stmt="${stmt^^}"
    
    case "$upper_stmt" in
        END|STOP)
            debug "Program ended"
            RUNNING=false
            ;;
        PRINT*)
            local args="${stmt#*PRINT}"
            execute_print "$args"
            ;;
        LET*)
            local args="${stmt#*LET}"
            execute_let "$args"
            ;;
        DIM*)
            local args="${stmt#*DIM}"
            execute_dim "$args"
            ;;
        FOR*)
            local args="${stmt#*FOR}"
            execute_for "$args"
            ;;
        NEXT*)
            execute_next "$stmt"
            ;;
        WHILE*)
            local args="${stmt#*WHILE}"
            execute_while "$args"
            ;;
        WEND*)
            execute_wend "$stmt"
            ;;
        IF*)
            local args="${stmt#*IF}"
            execute_if "$args"
            ;;
        GOTO*)
            local line_num="${stmt#*GOTO}"
            line_num=$(trim "$line_num")
            if [[ -z "${PROGRAM_LINES[$line_num]:-}" ]]; then
                error "GOTO to undefined line: $line_num"
            fi
            CURRENT_LINE="$line_num"
            debug "GOTO line $line_num"
            ;;
        GOSUB*)
            local line_num="${stmt#*GOSUB}"
            line_num=$(trim "$line_num")
            execute_gosub "$line_num"
            ;;
        RETURN)
            execute_return
            ;;
        *)
            # Check if it's an assignment without LET
            local assign_regex='^[A-Z][A-Z0-9_]*(\$|\([^)]+\))?[[:space:]]*='
            if [[ "$stmt" =~ $assign_regex ]]; then
                execute_let "$stmt"
            else
                error "Unknown statement: $stmt"
            fi
            ;;
    esac
}

# Run the program
run_program() {
    debug "Starting program execution"
    
    RUNNING=true
    
    # Start with first line
    local line_numbers
    readarray -t line_numbers < <(get_line_numbers)
    
    if [[ ${#line_numbers[@]} -eq 0 ]]; then
        error "No program lines to execute"
    fi
    
    CURRENT_LINE="${line_numbers[0]}"
    
    while [[ "$RUNNING" == "true" ]]; do
        if [[ -z "${PROGRAM_LINES[$CURRENT_LINE]:-}" ]]; then
            debug "End of program reached"
            break
        fi
        
        local line_content="${PROGRAM_LINES[$CURRENT_LINE]}"
        debug "Line $CURRENT_LINE: $line_content"
        
        execute_statement "$line_content"
        
        # Move to next line if not redirected
        if [[ "$RUNNING" == "true" ]]; then
            local next_line=$(find_next_line "$CURRENT_LINE")
            if [[ -z "$next_line" ]]; then
                debug "No more lines to execute"
                break
            fi
            CURRENT_LINE="$next_line"
        fi
    done
    
    debug "Program execution completed"
}

# Main function
main() {
    parse_args "$@"
    
    if [[ -z "${PROGRAM_FILE:-}" ]]; then
        usage
        exit 1
    fi
    
    load_program "$PROGRAM_FILE"
    run_program
}

# Run main function with all arguments
main "$@"
